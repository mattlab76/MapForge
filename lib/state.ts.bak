import { z } from "zod";
import { Direction, getDefaultMessageId, getMessage } from "@/lib/interfaces";

export const MappingRowSchema = z.object({
  id: z.string(),
  source: z.string().optional().default(""),
  destination: z.string().optional().default(""),
  status: z.enum(["open", "in_review", "clarified", "done"]).default("open"),
  comment: z.string().optional().default(""),
});

export type MappingRow = z.infer<typeof MappingRowSchema>;

export const RoundSchema = z.object({
  id: z.string(), // "R01"...
  rows: z.array(MappingRowSchema).default([]),
});
export type Round = z.infer<typeof RoundSchema>;

/**
 * AppState v3:
 * - direction: inbound/outbound separation (stored & separate localStorage slots)
 * - messageId: fixed interface/message definition (destination fields are derived from it)
 * - sourceFieldCatalog: paths from uploaded source JSON (optional)
 * - rounds: mapping rounds
 */
export const AppStateV3Schema = z.object({
  version: z.literal(3),
  updatedAt: z.string(),
  direction: z.enum(["inbound", "outbound"]),
  messageId: z.string(),
  sourceFieldCatalog: z.array(z.string()).default([]),
  rounds: z.array(RoundSchema),
  activeRoundId: z.string(),
});
export type AppState = z.infer<typeof AppStateV3Schema>;

/** Legacy v2 */
const AppStateV2Schema = z.object({
  version: z.literal(2),
  updatedAt: z.string(),
  messageId: z.string(),
  sourceFieldCatalog: z.array(z.string()).default([]),
  rounds: z.array(RoundSchema),
  activeRoundId: z.string(),
});

/** Legacy v1 */
const AppStateV1Schema = z.object({
  version: z.literal(1),
  updatedAt: z.string(),
  fieldCatalog: z.array(z.string()).default([]),
  rounds: z.array(RoundSchema),
  activeRoundId: z.string(),
});

export function storageKey(direction: Direction): string {
  return `mapforge_state_v3_${direction}`;
}

export function createEmptyState(direction: Direction, defaultMessageId?: string): AppState {
  const messageId = defaultMessageId ?? getDefaultMessageId(direction);
  const msg = getMessage(messageId);
  return {
    version: 3,
    updatedAt: new Date().toISOString(),
    direction,
    messageId: msg.id,
    sourceFieldCatalog: [],
    rounds: [{ id: "R01", rows: [] }],
    activeRoundId: "R01",
  };
}

export function normalizeRoundId(n: number): string {
  const s = String(n).padStart(2, "0");
  return `R${s}`;
}

export function validateState(input: unknown, fallbackDirection: Direction = "outbound"): AppState {
  const v3 = AppStateV3Schema.safeParse(input);
  if (v3.success) {
    const msg = getMessage(v3.data.messageId);
    return {
      ...v3.data,
      messageId: msg.id,
      sourceFieldCatalog: v3.data.sourceFieldCatalog ?? [],
      rounds: v3.data.rounds?.length ? v3.data.rounds : [{ id: "R01", rows: [] }],
      activeRoundId: v3.data.activeRoundId ?? "R01",
    };
  }

  const v2 = AppStateV2Schema.safeParse(input);
  if (v2.success) {
    // If message is outbound/inbound we can infer direction from the message.
    const msg = getMessage(v2.data.messageId);
    const direction: Direction = (msg as any).direction ?? fallbackDirection;
    const migrated = createEmptyState(direction, msg.id);
    migrated.updatedAt = v2.data.updatedAt;
    migrated.sourceFieldCatalog = v2.data.sourceFieldCatalog ?? [];
    migrated.rounds = v2.data.rounds?.length ? v2.data.rounds : migrated.rounds;
    migrated.activeRoundId = v2.data.activeRoundId ?? migrated.activeRoundId;
    return migrated;
  }

  const v1 = AppStateV1Schema.safeParse(input);
  if (v1.success) {
    const migrated = createEmptyState(fallbackDirection);
    migrated.updatedAt = v1.data.updatedAt;
    migrated.sourceFieldCatalog = v1.data.fieldCatalog ?? [];
    migrated.rounds = v1.data.rounds?.length ? v1.data.rounds : migrated.rounds;
    migrated.activeRoundId = v1.data.activeRoundId ?? migrated.activeRoundId;
    return migrated;
  }

  return createEmptyState(fallbackDirection);
}
