import { z } from "zod";
import type { Direction, ProjectV3 } from "@/lib/types";

export const MappingStatusSchema = z.enum(["open", "in_review", "clarified", "done"]);

const RowSchema = z.object({
  id: z.string().min(1),
  source: z.string(),
  destination: z.string(),
  status: MappingStatusSchema,
  comment: z.string().optional().default(""),
  rubric: z.string().optional(),
});

const RoundSchema = z.object({
  id: z.string().min(1),
  rows: z.array(RowSchema),
});

export const ProjectV3Schema = z.object({
  version: z.literal(3),
  updatedAt: z.string(),
  systemId: z.string().min(1),
  direction: z.enum(["inbound", "outbound"]),
  messageId: z.string().min(1),
  sourceCatalog: z.array(z.string()),
  destinationCatalog: z.array(z.string()),
  rubricEnabled: z.array(z.string()).optional().default([]),
  rounds: z.array(RoundSchema),
  activeRoundId: z.string().min(1),
});

export function storageKey(systemId: string, direction: Direction, messageId: string) {
  return `mapforge:v3:${systemId}:${direction}:${messageId}`;
}

export function makeEmptyProject(params: { systemId: string; direction: Direction; messageId: string }): ProjectV3 {
  const now = new Date().toISOString();
  return {
    version: 3,
    updatedAt: now,
    systemId: params.systemId,
    direction: params.direction,
    messageId: params.messageId,
    sourceCatalog: [],
    destinationCatalog: [],
    rubricEnabled: [],
    rounds: [{ id: "R01", rows: [] }],
    activeRoundId: "R01",
  };
}

export function normalizeInterfacePath(path: string): string {
  // Remove Lobster prefix and convert dot-notation to XPath-like slashes.
  let p = path ?? "";
  if (p.startsWith("Write_Interface.")) p = p.slice("Write_Interface.".length);
  // also handle accidental leading bang markers like !...!
  p = p.replace(/^!+/, "").replace(/!+$/, "");
  p = p.replaceAll(".", "/");
  // collapse duplicate slashes
  p = p.replace(/\/+/g, "/");
  return p;
}

export function normalizeProjectPaths(project: ProjectV3): ProjectV3 {
  const normalizeRow = (r: any) => ({
    ...r,
    destination: normalizeInterfacePath(r.destination),
  });
  return {
    ...project,
    sourceCatalog: project.sourceCatalog.map(normalizeInterfacePath),
    destinationCatalog: project.destinationCatalog.map(normalizeInterfacePath),
    rounds: project.rounds.map((round) => ({ ...round, rows: round.rows.map(normalizeRow) })),
  };
}

